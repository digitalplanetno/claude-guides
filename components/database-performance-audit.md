# Database Performance Audit Guide

> Универсальное руководство по аудиту производительности MySQL/MariaDB

## Философия аудита

**НЕ ДЕЛАЙ:**
- Static analysis кода для поиска индексов (код не знает частоту вызовов)
- Гадание "какие индексы нужны" без данных
- Добавление индексов "на всякий случай"

**ДЕЛАЙ:**
- Анализ через `performance_schema` (реальная статистика)
- Поиск запросов с плохим scan ratio
- Удаление неиспользуемых индексов
- Проверку инфраструктурных метрик

---

## Доступ к статистике

### Проверка наличия sys schema

```sql
SHOW DATABASES LIKE 'sys';
```

**Если есть sys** - используй удобные views:
- `sys.statement_analysis`
- `sys.schema_unused_indexes`

**Если нет sys** - работай напрямую с `performance_schema`:
- `performance_schema.events_statements_summary_by_digest`
- `performance_schema.table_io_waits_summary_by_index_usage`

### Проверка прав пользователя

```sql
SHOW GRANTS;
```

Для полного аудита нужен доступ к `performance_schema`. Если нет - используй `debian-sys-maint` (пароль в `/etc/mysql/debian.cnf`).

---

## 1. Quick Health Check

```sql
SELECT
    'Connections' as metric,
    CONCAT(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Threads_connected'),
        ' / ', @@max_connections,
        ' (', ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Max_used_connections') / @@max_connections * 100, 0), '% peak)'
    ) as value
UNION ALL SELECT 'Buffer Pool MB', ROUND(@@innodb_buffer_pool_size / 1024 / 1024)
UNION ALL SELECT 'Deadlocks', (SELECT VARIABLE_VALUE FROM performance_schema.global_status
    WHERE VARIABLE_NAME = 'Innodb_deadlocks')
UNION ALL SELECT 'Uptime Days', ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_status
    WHERE VARIABLE_NAME = 'Uptime') / 86400, 1);
```

---

## 2. Connection Health

```sql
SELECT
    @@max_connections as max_allowed,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Max_used_connections') as peak_used,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Threads_connected') as current_conn,
    CONCAT(ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Max_used_connections') / @@max_connections * 100, 1
    ), '%') as peak_percent;
```

| Peak % | Status | Action |
|--------|--------|--------|
| < 60% | OK | - |
| 60-80% | Warning | Планируй увеличение |
| > 80% | Critical | Увеличивай `max_connections` |

**Формула для воркеров:**
```
max_connections >= (PHP-FPM workers) + (Queue workers) + (Cron jobs) + 20% запас
```

---

## 3. Buffer Pool

```sql
SELECT
    ROUND(@@innodb_buffer_pool_size / 1024 / 1024) as buffer_pool_mb,
    (SELECT ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024)
     FROM information_schema.TABLES
     WHERE TABLE_SCHEMA = DATABASE()) as db_size_mb;
```

**Правило:** `buffer_pool >= db_size * 1.2`

**Конфиг:**
```ini
# /etc/mysql/mysql.conf.d/mysqld.cnf
innodb_buffer_pool_size = 1536M          # Под размер БД
innodb_buffer_pool_instances = 4          # Для параллелизма (1 на каждый GB)
```

---

## 4. Top Heavy Queries (Full Table Scans)

```sql
SELECT
    LEFT(DIGEST_TEXT, 80) as query,
    COUNT_STAR as calls,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 3) as total_sec,
    ROUND((SUM_TIMER_WAIT / COUNT_STAR) / 1000000000, 1) as avg_ms,
    SUM_ROWS_SENT as rows_sent,
    SUM_ROWS_EXAMINED as rows_scanned,
    ROUND(SUM_ROWS_EXAMINED / NULLIF(SUM_ROWS_SENT, 0), 0) as scan_ratio
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = DATABASE()
    AND SUM_ROWS_EXAMINED > 1000
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 15;
```

**Интерпретация scan_ratio:**
| Ratio | Meaning | Action |
|-------|---------|--------|
| 1-10 | Excellent | OK |
| 10-100 | Acceptable | Monitor |
| 100-1000 | Poor | Add index |
| > 1000 | Critical | Fix ASAP |

**Типичные решения:**
- `WHERE column = ?` без индекса → `CREATE INDEX`
- `WHERE column IS NOT NULL` → кэширование
- `LIKE '%search%'` → Full-text search
- `ORDER BY` без индекса → Composite index

---

## 5. Unused Indexes

```sql
SELECT
    OBJECT_NAME as tbl,
    INDEX_NAME as idx
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = DATABASE()
    AND INDEX_NAME IS NOT NULL
    AND INDEX_NAME != 'PRIMARY'
    AND COUNT_READ = 0
ORDER BY OBJECT_NAME;
```

**Важно:** Проверь uptime! Статистика сбрасывается при рестарте.

```sql
SELECT ROUND(VARIABLE_VALUE / 86400, 1) as uptime_days
FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Uptime';
```

**Безопасно удалять (uptime > 7 дней):**
- Single-column boolean indexes на редких фильтрах
- Дублирующие индексы
- Индексы на архивных таблицах

**НЕ удалять:**
- `*_foreign` (FK constraints)
- PRIMARY, UNIQUE
- Индексы созданные < 7 дней назад

---

## 6. N+1 Detection

```sql
SELECT
    LEFT(DIGEST_TEXT, 80) as query,
    COUNT_STAR as exec_count,
    ROUND((SUM_TIMER_WAIT / COUNT_STAR) / 1000000000, 2) as avg_ms
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = DATABASE()
    AND COUNT_STAR > 100
    AND DIGEST_TEXT LIKE 'SELECT%'
ORDER BY COUNT_STAR DESC
LIMIT 15;
```

**Признаки N+1:**
- `exec_count` в тысячах
- Простой `SELECT ... WHERE id = ?`
- `avg_ms` < 1ms

**Фикс (Laravel):**
```php
// Bad
foreach (Site::all() as $site) {
    echo $site->lastCheck->status; // N+1!
}

// Good
foreach (Site::with('lastCheck')->get() as $site) {
    echo $site->lastCheck->status;
}
```

---

## 7. Deadlocks

```sql
SELECT VARIABLE_VALUE as total_deadlocks
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Innodb_deadlocks';
```

**Если > 0:**
```sql
SHOW ENGINE INNODB STATUS\G
-- Секция: LATEST DETECTED DEADLOCK
```

**Типичные причины:**
- Параллельные воркеры обновляют одну запись
- Транзакции блокируют таблицы в разном порядке
- Long-running transactions

---

## 8. Table Sizes

```sql
SELECT
    TABLE_NAME as tbl,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) as total_mb,
    ROUND(DATA_LENGTH / 1024 / 1024, 2) as data_mb,
    ROUND(INDEX_LENGTH / 1024 / 1024, 2) as index_mb,
    TABLE_ROWS as rows
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = DATABASE()
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
LIMIT 10;
```

**Проблемные признаки:**
- `index_mb` > `data_mb` → слишком много индексов
- Таблица > 1GB → планируй архивацию/партиционирование
- `jobs` таблица раздута → проблема с воркерами

---

## Специфика стеков

### Laravel

```php
// config/database.php - connection pooling
'options' => [
    PDO::ATTR_PERSISTENT => true,
],

// Telescope для отлова N+1 в dev
// Debugbar для профилирования запросов
```

### Next.js + Prisma

```typescript
// Prisma query logging
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
})

// Connection pooling через PgBouncer для PostgreSQL
```

### Queue Workers

**Формула connections:**
```
workers * connections_per_worker + web_requests + buffer
```

**Laravel Horizon:** мониторинг воркеров и очередей

---

## Автоматизация

### Bash скрипт для cron

```bash
#!/bin/bash
# /usr/local/bin/mysql-health-check.sh

MYSQL_PWD=$(grep password /etc/mysql/debian.cnf | head -1 | cut -d'=' -f2 | tr -d ' ')
export MYSQL_PWD

mysql -u debian-sys-maint << 'SQL' | mail -s "MySQL Health $(date +%Y-%m-%d)" admin@example.com
SELECT 'Connections' as metric,
    CONCAT(@@max_connections, ' max, ',
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Max_used_connections'), ' peak') as value
UNION ALL
SELECT 'Deadlocks', (SELECT VARIABLE_VALUE FROM performance_schema.global_status
    WHERE VARIABLE_NAME = 'Innodb_deadlocks')
UNION ALL
SELECT 'Slow queries (>1s)',
    (SELECT COUNT(*) FROM performance_schema.events_statements_summary_by_digest
     WHERE AVG_TIMER_WAIT > 1000000000000);
SQL
```

### Cron schedule

```cron
# Daily health check
0 9 * * * /usr/local/bin/mysql-health-check.sh

# Weekly full audit
0 9 * * 1 /usr/local/bin/mysql-full-audit.sh
```

---

## Чеклист аудита

- [ ] `buffer_pool` >= размер БД
- [ ] Connections peak < 80%
- [ ] Нет запросов с scan_ratio > 1000
- [ ] Удалены неиспользуемые индексы (uptime > 7 дней)
- [ ] Deadlocks = 0
- [ ] Нет таблиц > 1GB без плана архивации
- [ ] N+1 проблемы исправлены

---

## Ресурсы

- [MySQL Performance Schema](https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html)
- [Percona Toolkit](https://www.percona.com/software/database-tools/percona-toolkit) - pt-query-digest
- [MySQLTuner](https://github.com/major/MySQLTuner-perl)
